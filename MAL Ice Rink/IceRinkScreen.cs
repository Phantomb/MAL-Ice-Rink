using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading;
using System.Collections;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MAL_Ice_Rink
{
    public partial class IceRinkScreen : Form
    {
        /*
         * This class exposes the internal state of the torus.
         * 
         * At simulation start an object of type Torus is generated, which performs the simulation according to the specified parameters.
         * 
         * Skaters move 1% of the Torus coordinate space per redraw.
         * Suppose the Torus represents a 100x100 metre rink and we redraw 1x per second. Movement speed equaltes to 1m/s.
         * 
         * Changing the 'speed' parameter effectively changes the number of draw events per second.
         * 
         */

        /*
         * Tweaks and edits:
         * - Decreasing Epsilon (and learning rate)
         * - Log mean reward over all agents over time 
         *      -> Instead of number of agents that chose this angle?
         *      -> Change histogram
         * - 
         */

        private bool sim_running { get; set; }
        private System.Threading.Timer refreshTimer;

        public IceRinkScreen()
        {
            InitializeComponent();

            // Populate combo boxes
            // (VS throws a hissy fit if we do this in the partial IceRinkScreen class generated by the designer.)
            foreach (int x in System.Enum.GetValues(typeof(DirectionForComboBox)))
            {
                this.comboBoxNumAngles.Items.Add((x.ToString()));
            }
            foreach (var x in System.Enum.GetNames(typeof(Palette)))
            {
                this.comboBoxPalette.Items.Add(x);
            }

            // Create a bitmap to draw on.
            panelDisplay.Image = new Bitmap(panelDisplay.Width, panelDisplay.Height);
            sim_running = false;
        }

        private void buttonStartStop_Click(object sender, EventArgs e)
        {

            if (!sim_running)
            {
                // Change button text.
                buttonStartStop.Text = "Reset";

                // Flip bool.
                sim_running = true;

                // Lock parameter settings.
                layoutPanelForParameterControls.Enabled = false;

                // Update internal Parameters
                Parameters.InitParameters(
                    numericUpDownNumSkaters.Value,
                    comboBoxNumAngles.Text,
                    numericUpDownCollisionRadius.Value,
                    numericUpDownSkaterSpeed.Value,
                    numericUpDownSuccessfullMove.Value,
                    numericUpDownFailedMoveReward.Value,
                    checkBoxModifyRewards.Checked,
                    checkBoxLearningRateDecreasing.Checked,
                    numericUpDownLearningRate.Value,
                    checkBoxEpsilonDecreasing.Checked,
                    numericUpDownEpsilon.Value, 
                    numericUpDownSkaterDotSize.Value, 
                    comboBoxPalette.Text, 
                    numericUpDownFadeSpeed.Value);

                // Prep torus, pass parameter: Number of skaters
                Torus.InitializeTorus();

                //Clear Chart
                if (Parameters.AverageOnly)
                {
                    chartCollisions.Series[0].Points.Clear();
                    if (chartCollisions.Series.Count > 1) chartCollisions.Series.RemoveAt(1);
                    chartRecentCollisions.Series[0].Points.Clear();
                    if (chartRecentCollisions.Series.Count > 1) chartRecentCollisions.Series.RemoveAt(1);
                }
                else
                {
                    chartCollisions.Series[0].Points.Clear();
                    chartCollisions.Series[1].Points.Clear();
                    chartRecentCollisions.Series[0].Points.Clear();
                    chartRecentCollisions.Series[1].Points.Clear();
                }

                // New log file.
                Logging.NewLogFile();

                // Start timer. Refreshes the simulation.
                refreshTimer = new System.Threading.Timer(panelCycle, null, 1000, (int)(1000 / Parameters.MovementSpeed));

            }
            else
            {
                // Reset initial state; re-enable controls.
                buttonStartStop.Text = "Start";
                sim_running = false;
                layoutPanelForParameterControls.Enabled = true;

                // Kill timer thread.
                refreshTimer.Dispose();

                // Stop logging
                Logging.EndLogging();

                // Clear display area.
                panelDisplay.Invalidate();

                Torus.Clear();
            }
        }

        private void panelCycle(object state)
        {
            // Update internal state of Torus
            Torus.Update();

            // On two threads: Invalidate display (paint event will be run on seperate thread) and calculate new internal state (seperate thread too).
            Parallel.Invoke(() => panelDisplay.Invalidate(), () => Torus.DoCycle());
        }

        private void ChartHistogramGenerateData()
        {
            chartAngleDistribution.Series[0].Points.Clear();
            // Chart 1: visualise distribution of angles
            // Get the percentage of skaters moving in that direction.
            for (int i = 0; i < Parameters.NumMoveDirections; i++)
            {
                chartAngleDistribution.Series[0].Points.AddXY(Parameters.DirectionList[i] * (180 / Math.PI), Torus.actionHistogram[i] * 100 / (float)Parameters.NumSkaters);
            }
        }
        private void ChartCollisionsGenerateData()
        {
            //CaLculate the moving average over the last $period cycles
            int period = 50;

            if (sim_running)
            {
                // Add points to charts
                if (Torus.CycleCount > (ulong)period)
                {
                    float tempaverage = 0f;
                    for (int i = (int)Torus.CycleCount - period; i < (int)Torus.CycleCount; i++)
                    {
                        tempaverage += Torus.collisions[i];
                    }
                    tempaverage /= period;
                    //simpleMovingAverage = simpleMovingAverage + (float)Torus.collisionCount / period - (float)Torus.collisions[(int)Torus.CycleCount - period] / period;

                    // Add the data point to the chart
                    chartCollisions.Series[0].Points.AddXY(Torus.CycleCount, tempaverage);
                    chartCollisions.Series[1].Points.AddXY(Torus.CycleCount, Torus.collisionCount);
                    chartRecentCollisions.Series[0].Points.AddXY(Torus.CycleCount, tempaverage);
                    chartRecentCollisions.Series[1].Points.AddXY(Torus.CycleCount, Torus.collisionCount);
                }
                else
                {
                    chartCollisions.Series[0].Points.AddXY(Torus.CycleCount, 0);
                    chartCollisions.Series[1].Points.AddXY(Torus.CycleCount, Torus.collisionCount);
                    chartRecentCollisions.Series[0].Points.AddXY(Torus.CycleCount, 0);
                    chartRecentCollisions.Series[1].Points.AddXY(Torus.CycleCount, Torus.collisionCount);
                }

                // Remove points if the count is > param.
                if (chartCollisions.Series[0].Points.Count > Parameters.MaxChartPoints)
                {
                    chartCollisions.Series[0].Points.RemoveAt(0);
                    chartCollisions.Series[1].Points.RemoveAt(0);
                }
                if (chartRecentCollisions.Series[0].Points.Count > Parameters.MaxRecentChartPoints)
                {
                    chartRecentCollisions.Series[0].Points.RemoveAt(0);
                    chartRecentCollisions.Series[1].Points.RemoveAt(0);
                }
            }
            else
            {
                chartCollisions.Series[0].Points.Clear();
                chartCollisions.Series[1].Points.Clear();
                chartRecentCollisions.Series[0].Points.Clear();
                chartRecentCollisions.Series[1].Points.Clear();
            }
        }
        private void SingleSeriesChartCollisionsGenerateData()
        {
            //CaLculate the moving average over the last $period cycles
            int period = 50;

            if (sim_running)
            {
                // Add points to charts
                if (Torus.CycleCount > (ulong)period)
                {
                    float tempaverage = 0f;
                    for (int i = (int)Torus.CycleCount - period; i < (int)Torus.CycleCount; i++)
                    {
                        tempaverage += Torus.collisions[i];
                    }
                    tempaverage /= period;

                    // Add the data point to the chart
                    chartCollisions.Series[0].Points.AddXY(Torus.CycleCount, tempaverage);
                    chartRecentCollisions.Series[0].Points.AddXY(Torus.CycleCount, tempaverage);

                    if (tempaverage > chartCollisions.ChartAreas[0].AxisY.Maximum) chartCollisions.ChartAreas[0].RecalculateAxesScale();
                    if (tempaverage > chartRecentCollisions.ChartAreas[0].AxisY.Maximum) chartRecentCollisions.ChartAreas[0].RecalculateAxesScale();
                }
                else
                {
                    chartCollisions.Series[0].Points.AddXY(Torus.CycleCount, 0);
                    chartRecentCollisions.Series[0].Points.AddXY(Torus.CycleCount, 0);
                }

                // Remove points if the count is > param.
                while (chartCollisions.Series[0].Points.Count > Parameters.MaxChartPoints)
                    chartCollisions.Series[0].Points.RemoveAt(0);
                while (chartRecentCollisions.Series[0].Points.Count > Parameters.MaxRecentChartPoints)
                    chartRecentCollisions.Series[0].Points.RemoveAt(0);
            }
            else
            {
                chartCollisions.Series[0].Points.Clear();
                chartRecentCollisions.Series[0].Points.Clear();
            }
        }

        private void panelDisplay_Paint(object sender, PaintEventArgs e)
        {
            if (sim_running)
            {
                numericUpDownEpsilon.Value = (decimal)Parameters.Epsilon;
                numericUpDownLearningRate.Value = (decimal)Parameters.LearningRate;
            }

            using (Graphics gr = Graphics.FromImage(panelDisplay.Image))
            {
                // Clear canvas prior to repaint.
                gr.Clear(Color.FromArgb(154, 154, 154));

                if (!sim_running)
                {
                    // If this paint event was triggered because the reset button was pressed:
                    // Show message & abort method with empty return.
                    labelStopped.Visible = true;
                    return;
                }

                // Ensure stop message is hidden.
                labelStopped.Visible = false;

                // Draw skaters.
                int skaterXPosition;
                int skaterYPosition;

                int radius = Parameters.DotSize / 2;
                float widthRadius = (float)Parameters.CollisionRadius * panelDisplay.Image.Width;
                float heightRadius = (float)Parameters.CollisionRadius * panelDisplay.Image.Height;
                foreach (Skater s in Torus.Skaters)
                {
                    // Convert to actual window positions.
                    skaterXPosition = (int)(s.X * panelDisplay.Image.Width);
                    skaterYPosition = (int)(s.Y * panelDisplay.Image.Height);

                    // Draw initial position (i == 0 && j == 0), draw extras for visibility.

                    for (int i = -radius; i < radius; i++)
                    {
                        for (int j = -radius; j < radius; j++)
                        {
                            ((Bitmap)panelDisplay.Image).SetPixel(Shared.Mod((skaterXPosition + i), panelDisplay.Width), Shared.Mod((skaterYPosition + j), panelDisplay.Height), s.Color);
                        }
                    }

                    // Draw the Collision Radius
                    if (Parameters.ShowRadius)
                    {
                        gr.DrawEllipse(Pens.DarkGreen, skaterXPosition - widthRadius / 2, skaterYPosition - heightRadius / 2, widthRadius, heightRadius);
                    }
                }
            }

            ChartHistogramGenerateData();
            if (Parameters.AverageOnly)
                SingleSeriesChartCollisionsGenerateData();
            else ChartCollisionsGenerateData();


            Logging.LogDataLine(Torus.CycleCount, Torus.collisionCount, Torus.actionHistogram, Torus.rewardHistogram);

        }

        private void checkBoxShowRadius_CheckedChanged(object sender, EventArgs e)
        {
            Parameters.ShowRadius = checkBoxShowRadius.Checked;
        }

        private void checkBoxLearningRateDecreasing_CheckedChanged(object sender, EventArgs e)
        {
            numericUpDownLearningRate.Enabled = !numericUpDownLearningRate.Enabled;
        }

        private void checkBoxEpsilonDecreasing_CheckedChanged(object sender, EventArgs e)
        {
            numericUpDownEpsilon.Enabled = !numericUpDownEpsilon.Enabled;
        }
    }
}
